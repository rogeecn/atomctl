// Code generated by the atomctl ; DO NOT EDIT.
// Code generated by the atomctl ; DO NOT EDIT.
// Code generated by the atomctl ; DO NOT EDIT.
package model

import (
	"context"
	"time"
	"github.com/samber/lo"
	. "github.com/go-jet/jet/v2/postgres"
	log "github.com/sirupsen/logrus"
)
// conds
{{- if .SoftDelete }}
func (m *{{.PascalTable}}) CondNotDeleted() Cond {
	return func(cond BoolExpression) BoolExpression {
		return cond.AND(tbl{{.PascalTable}}.DeletedAt.IS_NULL())
	}
}

func (m *{{.PascalTable}}) CondDeleted() Cond {
	return func(cond BoolExpression) BoolExpression {
		return cond.AND(tbl{{.PascalTable}}.DeletedAt.IS_NOT_NULL())
	}
}
{{- end}}

func (m *{{.PascalTable}}) CondID(id int64) Cond {
	return func(cond BoolExpression) BoolExpression {
		return cond.AND(tbl{{.PascalTable}}.ID.EQ(Int(id)))
	}
}

// funcs
func (m *{{.PascalTable}}) log() *log.Entry {
	return log.WithField("model", "{{.PascalTable}}")
}

func (m *{{.PascalTable}}) Create(ctx context.Context) error {
	{{- if .HasCreatedAt}}
	m.CreatedAt = time.Now()
	{{- end}}

	{{- if .HasUpdatedAt}}
	m.UpdatedAt = time.Now()
	{{- end}}


	stmt := tbl{{.PascalTable}}.INSERT(tbl{{.PascalTable}}.MutableColumns).MODEL(m).RETURNING(tbl{{.PascalTable}}.AllColumns)
	m.log().WithField("func","Create").Info( stmt.DebugSql())

	if err := stmt.QueryContext(ctx, db, m); err != nil {
		m.log().WithField("func","Create").Errorf("error creating {{.PascalTable}} item: %v", err)
		return err
	}

	m.log().WithField("func","Create").Infof("{{.PascalTable}} item created successfully")
	return nil
}


func (m *{{.PascalTable}}) BatchCreate(ctx context.Context, models []*{{.PascalTable}}) error {
	stmt := tbl{{.PascalTable}}.INSERT(tbl{{.PascalTable}}.MutableColumns).MODELS(models)
	m.log().WithField("func", "BatchCreate").Info(stmt.DebugSql())

	if _, err := stmt.ExecContext(ctx, db); err != nil {
		m.log().WithField("func","Create").Errorf("error creating {{.PascalTable}} item: %v", err)
		return err
	}

	m.log().WithField("func", "BatchCreate").Infof("{{.PascalTable}} items created successfully")
	return nil
}

{{- if .SoftDelete }}
func (m *{{.PascalTable}}) Delete(ctx context.Context) error {
	stmt := tbl{{.PascalTable}}.UPDATE().SET(tbl{{.PascalTable}}.DeletedAt.SET(TimestampT(time.Now()))).WHERE(tbl{{.PascalTable}}.ID.EQ(Int(m.ID)))
	m.log().WithField("func", "SoftDelete").Info(stmt.DebugSql())

	if err := stmt.QueryContext(ctx, db, m); err != nil {
		m.log().WithField("func","SoftDelete").Errorf("error soft deleting {{.PascalTable}} item: %v", err)
		return err
	}

	m.log().WithField("func", "SoftDelete").Infof("{{.PascalTable}} item soft deleted successfully")
	return nil
}

// BatchDelete
func (m *{{.PascalTable}}) BatchDelete(ctx context.Context, ids []int64) error {
	condIds := lo.Map(ids, func(id int64, _ int) Expression {
		return Int64(id)
	})

	stmt := tbl{{.PascalTable}}.UPDATE().SET(tbl{{.PascalTable}}.DeletedAt.SET(TimestampT(time.Now()))).WHERE(tbl{{.PascalTable}}.ID.IN(condIds...))
	m.log().WithField("func", "BatchSoftDelete").Info(stmt.DebugSql())

	if err := stmt.QueryContext(ctx, db, m); err != nil {
		m.log().WithField("func","BatchSoftDelete").Errorf("error soft deleting {{.PascalTable}} items: %v", err)
		return err
	}

	m.log().WithField("func", "BatchSoftDelete").WithField("ids", ids).Infof("{{.PascalTable}} items soft deleted successfully")
	return nil
}


func (m *{{.PascalTable}}) ForceDelete(ctx context.Context) error {
	stmt := tbl{{.PascalTable}}.DELETE().WHERE(tbl{{.PascalTable}}.ID.EQ(Int(m.ID)))
	m.log().WithField("func", "Delete").Info(stmt.DebugSql())

	if _, err := stmt.ExecContext(ctx, db); err != nil {
		m.log().WithField("func","Delete").Errorf("error deleting {{.PascalTable}} item: %v", err)
		return err
	}

	m.log().WithField("func", "Delete").Infof("{{.PascalTable}} item deleted successfully")
	return nil
}

func (m *{{.PascalTable}}) BatchForceDelete(ctx context.Context, ids []int64) error {
	condIds := lo.Map(ids, func(id int64, _ int) Expression {
		return Int64(id)
	})

	stmt := tbl{{.PascalTable}}.DELETE().WHERE(tbl{{.PascalTable}}.ID.IN(condIds...))
	m.log().WithField("func", "BatchDelete").Info(stmt.DebugSql())

	if _, err := stmt.ExecContext(ctx, db); err != nil {
		m.log().WithField("func","BatchForceDelete").Errorf("error deleting {{.PascalTable}} items: %v", err)
		return err
	}

	m.log().WithField("func", "BatchForceDelete").WithField("ids", ids).Infof("{{.PascalTable}} items deleted successfully")
	return nil
}
{{- else}}
func (m *{{.PascalTable}}) Delete(ctx context.Context) error {
	stmt := tbl{{.PascalTable}}.DELETE().WHERE(tbl{{.PascalTable}}.ID.EQ(Int(m.ID)))
	m.log().WithField("func", "Delete").Info(stmt.DebugSql())

	if err := stmt.QueryContext(ctx, db, m); err != nil {
		m.log().WithField("func","Delete").Errorf("error deleting {{.PascalTable}} item: %v", err)
		return err
	}

	m.log().WithField("func", "Delete").Infof("{{.PascalTable}} item deleted successfully")
	return nil
}

// BatchDelete
func (m *{{.PascalTable}}) BatchDelete(ctx context.Context, ids []int64) error {
	condIds := lo.Map(ids, func(id int64, _ int) Expression {
		return Int64(id)
	})

	stmt := tbl{{.PascalTable}}.DELETE().WHERE(tbl{{.PascalTable}}.ID.IN(condIds...))
	m.log().WithField("func", "BatchDelete").Info(stmt.DebugSql())

	if err := stmt.QueryContext(ctx, db, m); err != nil {
		m.log().WithField("func","BatchDelete").Errorf("error deleting {{.PascalTable}} items: %v", err)
		return err
	}

	m.log().WithField("func", "BatchDelete").WithField("ids", ids).Infof("{{.PascalTable}} items deleted successfully")
	return nil
}
{{- end}}

func (m *{{.PascalTable}}) Update(ctx context.Context) error {
	{{- if .HasUpdatedAt}}
	m.UpdatedAt = time.Now()
	{{- end}}

	stmt := tbl{{.PascalTable}}.UPDATE(tbl{{.PascalTable}}UpdateMutableColumns).MODEL(m).WHERE(tbl{{.PascalTable}}.ID.EQ(Int(m.ID))).RETURNING(tbl{{.PascalTable}}.AllColumns)
	m.log().WithField("func", "Update").Info(stmt.DebugSql())

	if err := stmt.QueryContext(ctx, db, m); err != nil {
		m.log().WithField("func","Update").Errorf("error updating {{.PascalTable}} item: %v", err)
		return err
	}

	m.log().WithField("func", "Update").Infof("{{.PascalTable}} item updated successfully")
	return nil
}

// GetByCond
func (m *{{.PascalTable}}) GetByCond(ctx context.Context, conds ...Cond) (*{{.PascalTable}}, error) {
	cond := CondTrue(conds...)

	stmt := tbl{{.PascalTable}}.SELECT(tbl{{.PascalTable}}.AllColumns).WHERE(cond)
	m.log().WithField("func", "GetByCond").Info(stmt.DebugSql())

	if err := stmt.QueryContext(ctx, db, m); err != nil {
		m.log().WithField("func","GetByCond").Errorf("error getting {{.PascalTable}} item by ID: %v", err)
		return nil, err
	}

	m.log().WithField("func", "GetByCond").Infof("{{.PascalTable}} item retrieved successfully")
	return m, nil
}

// GetByID
func (m *{{.PascalTable}}) GetByID(ctx context.Context, id int64, conds ...Cond) (*{{.PascalTable}}, error) {
	return m.GetByCond(ctx, CondJoin(m.CondID(id), conds...)...)
}


// Count
func (m *{{.PascalTable}}) Count(ctx context.Context, conds ...Cond) (int64, error) {
	cond := CondTrue(conds...)

	stmt := tbl{{.PascalTable}}.SELECT(COUNT(tbl{{.PascalTable}}.ID).AS("count")).WHERE(cond)
	m.log().Infof("sql: %s", stmt.DebugSql())

	var count struct {
		Count int64
	}

	if err := stmt.QueryContext(ctx, db, &count); err != nil {
		m.log().Errorf("error counting {{.PascalTable}} items: %v", err)
		return 0, err
	}

	return count.Count, nil
}

